<h1>Regular Expressions</h1>
<blockquote>
<p>Regex is eager, greedy</p>
</blockquote>
<h2>Regex mode</h2>
<table>
<thead>
<tr>
<th>Type</th>
<th>Example</th>
<th>Text</th>
<th>Match</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Standard</strong></td>
<td><code>/abc/</code></td>
<td>&quot;abc abc ABC&quot;</td>
<td>&quot;<strong>abc</strong> abc ABC&quot;</td>
</tr>
<tr>
<td><strong>Global</strong></td>
<td><code>/abc/g</code></td>
<td>&quot;abc abc ABC&quot;</td>
<td>&quot;<strong>abc</strong> <strong>abc</strong> ABC&quot;</td>
</tr>
<tr>
<td><strong>Case-insensitive</strong></td>
<td><code>/abc/i</code></td>
<td>&quot;AbC&quot;</td>
<td>&quot;<strong>AbC</strong>&quot;</td>
</tr>
<tr>
<td><strong>Multiline</strong></td>
<td><code>/abc/m</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Dot-matches-all</strong></td>
<td><code>/a.c/s</code></td>
<td>&quot;a\nc&quot;</td>
<td>&quot;<strong>a\nc</strong>&quot;</td>
</tr>
</tbody>
</table>
<hr>
<h2>Metacharacters</h2>
<p><code>\ . * + - {} [] ^ $ | ? () : ! =</code><br>
They can have more than one meanings</p>
<hr>
<h2>Single Character</h2>
<table>
<thead>
<tr>
<th>Metacharacter</th>
<th>Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.</code></td>
<td>Wildcard</td>
<td>any character except newline</td>
</tr>
<tr>
<td><code>\</code></td>
<td>Escaping</td>
<td>escape the next character <strong>only for metacharacters</strong></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Example</th>
<th>Match</th>
<th>Not match</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/h.t/</code></td>
<td><strong>&quot;hat&quot; &quot;hot&quot; &quot;h\tt&quot; &quot;h t&quot; &quot;h$t&quot;</strong></td>
<td>&quot;h\nt&quot;</td>
</tr>
<tr>
<td><code>/9.00/</code></td>
<td><strong>&quot;9.00&quot; &quot;9500&quot; &quot;9a00&quot; &quot;9:00&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/9\.00/</code></td>
<td><strong>&quot;9.00&quot;</strong></td>
<td>&quot;9500&quot; &quot;9a00&quot; &quot;9:00&quot;</td>
</tr>
</tbody>
</table>
<h3>Special characters</h3>
<table>
<thead>
<tr>
<th>Name</th>
<th>Code</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tabs</td>
<td><code>\t</code></td>
</tr>
<tr>
<td>Line returns</td>
<td><code>\r</code>,<code>\n</code>, <code>\r\n</code></td>
</tr>
<tr>
<td>Non-printable characters</td>
<td>bell (<code>\a</code>), escape (<code>\e</code>), form feed (<code>\f</code>), vertical tab(<code>\v</code>)</td>
</tr>
<tr>
<td>ASCII or ANSI codes</td>
<td><code>\xA9</code></td>
</tr>
</tbody>
</table>
<hr>
<h2>Character Set</h2>
<table>
<thead>
<tr>
<th>Metacharacter</th>
<th>Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[]</code></td>
<td>Character Set</td>
<td>match <strong>one</strong> character defined between character set</td>
</tr>
<tr>
<td><code>-</code></td>
<td></td>
<td>range of characters <strong>only</strong> when inside <code>[]</code></td>
</tr>
<tr>
<td><code>^</code></td>
<td></td>
<td>negate a character set when it is the <strong>first</strong> character in side <code>[]</code></td>
</tr>
<tr>
<td><code>\d</code></td>
<td></td>
<td>Digit or <code>[0-9]</code></td>
</tr>
<tr>
<td><code>\w</code></td>
<td></td>
<td>Word character or <code>[a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td><code>\s</code></td>
<td></td>
<td>Whitespace or <code>[ \t\r\n]</code></td>
</tr>
<tr>
<td><code>\D</code></td>
<td></td>
<td>Not digit or <code>[^0-9]</code></td>
</tr>
<tr>
<td><code>\W</code></td>
<td></td>
<td>Not word character or <code>[^a-zA-Z0-9_]</code></td>
</tr>
<tr>
<td><code>\S</code></td>
<td></td>
<td>Not whitespace or <code>[ \t\r\n]</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>These metacharacters <code>] - ^ \</code> need escaping inside <code>[]</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>Example</th>
<th>Match</th>
<th>Not match</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/[ueoai]/</code></td>
<td>any one vowel</td>
<td></td>
</tr>
<tr>
<td><code>/gr[ea]y/</code></td>
<td><strong>&quot;grey&quot; &quot;gray&quot;</strong></td>
<td>&quot;greay&quot;</td>
</tr>
<tr>
<td><code>/gr[ea]t/</code></td>
<td><strong>&quot;gret&quot; &quot;grat&quot;</strong></td>
<td>&quot;great&quot;</td>
</tr>
<tr>
<td><code>/gr[ea][ae]t/</code></td>
<td><strong>&quot;greet&quot; &quot;graat&quot; &quot;great&quot; &quot;graet&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>[0-9]</code></td>
<td>a number from 0 to 9</td>
<td></td>
</tr>
<tr>
<td><code>[A-Za-z]</code></td>
<td>a normal or capitalized character</td>
<td></td>
</tr>
<tr>
<td><code>[50-99]</code></td>
<td>a number from 0 to 9</td>
<td>any number from 50 to 99</td>
</tr>
<tr>
<td><code>/[^ueoai]/</code></td>
<td>any one is not a vowel</td>
<td></td>
</tr>
<tr>
<td><code>/see[^mn]/</code></td>
<td><strong>&quot;see#&quot; &quot;see&amp;&quot; &quot;sees&quot; &quot;see &quot;</strong></td>
<td>&quot;seem&quot; &quot;seen&quot; &quot;see&quot;</td>
</tr>
<tr>
<td><code>/var[[(][0-9][\])]/</code></td>
<td><strong>&quot;var(0)&quot; &quot;var[1]&quot; &quot;var(9]&quot; &quot;var[5)&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/file[0\-\\_]1/</code></td>
<td><strong>&quot;file-1&quot; &quot;file_1&quot; &quot;file01&quot; &quot;file\1&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/\d\d\d\d/</code></td>
<td><strong>&quot;1989&quot; &quot;7865&quot;</strong></td>
<td>&quot;187a&quot; &quot;1sd9&quot;</td>
</tr>
<tr>
<td><code>/\w\w\w/</code></td>
<td><strong>&quot;___&quot; &quot;a9c&quot; &quot;1_a&quot; &quot;Ax3&quot;</strong></td>
<td>&quot;a-9&quot;</td>
</tr>
<tr>
<td><code>/\w\s\w\w/</code></td>
<td><strong>&quot;9 ds&quot; &quot;A 98&quot; &quot;7\t89&quot; &quot;_\nA9&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/\w\-/</code></td>
<td>any word character or hyphen</td>
<td></td>
</tr>
<tr>
<td><code>/\d\s/</code></td>
<td>any digit or whitespace character</td>
<td></td>
</tr>
<tr>
<td><code>/^\d/</code></td>
<td><code>/\D/</code> or <code>/^0-9/</code> any non-digit character</td>
<td></td>
</tr>
<tr>
<td><code>/[^\d\s]/</code></td>
<td><strong>NOT</strong> digit <strong>OR</strong> whitespace character <strong>&quot;a&quot; &quot;b&quot;  &quot;Z&quot; &quot;-&quot; &quot;_&quot;</strong></td>
<td>&quot;1&quot; &quot; &quot; &quot;\t&quot; &quot;\n&quot;</td>
</tr>
<tr>
<td><code>/[\D\S]/</code></td>
<td><strong>EITHER NOT</strong> digit (can be space or word) <strong>OR NOT</strong> whitespace (can be digit or word) character</td>
<td></td>
</tr>
</tbody>
</table>
<hr>
<h2>Repetition</h2>
<table>
<thead>
<tr>
<th>Metacharacter</th>
<th>Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>*</code></td>
<td></td>
<td>Preceding item &gt;= 0</td>
</tr>
<tr>
<td><code>+</code></td>
<td></td>
<td>Preceding item &gt;= 1</td>
</tr>
<tr>
<td><code>?</code></td>
<td>option</td>
<td>Preceding item 0 or 1</td>
</tr>
<tr>
<td><code>{}</code></td>
<td>quantified repetition</td>
<td>Preceding item is repeated with specific times <code>{min,max}</code> <strong>min&gt;=0 is mandatory, max&gt;0 is optional</strong></td>
</tr>
<tr>
<td><code>?</code></td>
<td>lazy</td>
<td>Make preceding quantifier lazy: <code>*?</code>, <code>+?</code>, <code>??</code>, <code>{min,max}?</code></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Example</th>
<th>Match</th>
<th>Not match</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/apps*/</code></td>
<td><strong>&quot;app&quot; &quot;apps&quot; &quot;appssssssss&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/apps+/</code></td>
<td><strong>&quot;apps&quot; &quot;appssssssss&quot;</strong></td>
<td>&quot;app&quot;</td>
</tr>
<tr>
<td><code>/apps?/</code></td>
<td><strong>&quot;app&quot; &quot;apps&quot;</strong></td>
<td>&quot;appsssssss&quot;</td>
</tr>
<tr>
<td><code>/\d\d\d\d*/</code></td>
<td>three digits or more</td>
<td></td>
</tr>
<tr>
<td><code>/\d\d\d+/</code></td>
<td>three digits or more</td>
<td></td>
</tr>
<tr>
<td><code>/\d{4,8}/</code></td>
<td>number has 4 to 8 digits</td>
<td></td>
</tr>
<tr>
<td><code>/\d{4,}/</code></td>
<td>number has at least 4 digits or more</td>
<td></td>
</tr>
<tr>
<td><code>/\d{4}/</code></td>
<td>number has 4 digits</td>
<td></td>
</tr>
<tr>
<td><code>/\d{0,}/</code></td>
<td>or <code>/\d*/</code></td>
<td></td>
</tr>
<tr>
<td><code>/\d{1,}/</code></td>
<td>or <code>/\d+/</code></td>
<td></td>
</tr>
<tr>
<td><code>/\d{3}-\d{3}-\d{4}/</code></td>
<td><strong>&quot;786-787-3378&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/.+\.jpg/</code></td>
<td><strong>&quot;image.jpg&quot; &quot;filename.jpg&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/.*[0-9]+/</code></td>
<td><strong>&quot;Page 789&quot;</strong> but the first part of regex <code>/.*/</code> matches <code>&quot;Page 78&quot;</code> and the second part <code>/[0-9]+/</code> matches <code>&quot;9&quot;</code></td>
<td></td>
</tr>
<tr>
<td><code>/.*?[0-9]+/</code></td>
<td><strong>&quot;Page 789&quot;</strong> but the first part of regex <code>/.*/</code> matches <code>&quot;Page &quot;</code> and the second part <code>/[0-9]+/</code> matches <code>&quot;789&quot;</code></td>
<td></td>
</tr>
<tr>
<td><code>/.*?[0-9]*?//</code></td>
<td>match nothing because of two parts of regex are lazy</td>
<td></td>
</tr>
<tr>
<td><code>/'.+', '.+'/</code></td>
<td><strong>&quot;'Abc', 'Xyz', 'Inc.com'&quot;</strong> the first <code>/'.+', /</code> matches <code>&quot;'Abc', 'Xyz', &quot;</code> and the second part <code>/'.+'/</code> matches <code>&quot;'Inc.com'&quot;</code></td>
<td></td>
</tr>
<tr>
<td><code>/'.+?', '.+?'/</code></td>
<td><strong>&quot;'Abc', 'Xyz'&quot;</strong> the first <code>/'.+?', /</code> matches <code>&quot;'Abc', &quot;</code> and the second part <code>/'.+?'/</code> matches <code>&quot;'Xyz'&quot;</code></td>
<td>&quot;, 'Inc.com'&quot;</td>
</tr>
<tr>
<td><code>/\d+\w+\d+/</code></td>
<td><strong>&quot;07_FY_08_report_99&quot;</strong>, <code>/\w+/</code> matches <code>&quot;_FY_08_report_&quot;</code></td>
<td></td>
</tr>
<tr>
<td><code>/\d+\w+?\d+/</code></td>
<td><strong>&quot;07_FY_08&quot;</strong>, <code>/\w+/</code> matches <code>&quot;_FY_&quot;</code></td>
<td>&quot;_report_99&quot;</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Regex repetition is greedy, match as much as possible before giving control to the next regex</p>
</blockquote>
<blockquote>
<p>Speed = efficient matching + less backtracking</p>
<ul>
<li><code>/.+/</code> is faster than <code>/.*/</code></li>
<li><code>/.{5}/</code> and <code>/.{3,7}/</code> are even faster</li>
<li>narrow the scope: <code>/.+/</code> =&gt; <code>/[A-Za-z]+/</code></li>
<li>clearer starting and ending point: <code>/&lt;.+&gt;/</code> =&gt; <code>/&lt;[^&gt;]+&gt;/</code></li>
</ul>
</blockquote>
<h2>Grouping</h2>
<blockquote>
<p>Cannot be use inside character set <code>[]</code></p>
</blockquote>
<table>
<thead>
<tr>
<th>Metacharacter</th>
<th>Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>()</code></td>
<td></td>
<td>Content inside as a group (may have many characters)</td>
</tr>
<tr>
<td><code>|</code></td>
<td>alternation, OR</td>
<td>Match previous or next expression</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Example</th>
<th>Match</th>
<th>Not match</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/(abc)+/</code></td>
<td><strong>&quot;abc&quot; &quot;abcabc&quot; &quot;abcabcabc&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(in)?complete/</code></td>
<td><strong>&quot;complete&quot; &quot;incomplete&quot;</strong></td>
<td>&quot;ncomplete&quot; &quot;icomplete&quot;</td>
</tr>
<tr>
<td><code>/apple(s)?/</code></td>
<td>same as <code>/apples?/</code> but may look clearer</td>
<td></td>
</tr>
<tr>
<td><code>/(apple|banana)/</code></td>
<td><strong>&quot;apple&quot; &quot;banana&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(apple (juice|cake))/</code></td>
<td><strong>&quot;apple juice&quot; &quot;apple cake&quot;</strong></td>
<td>&quot;apple &quot; &quot;cake&quot; &quot;juice&quot;</td>
</tr>
<tr>
<td><code>/(peanut|peanutbutter)/</code></td>
<td><strong>only &quot;peanut&quot; in &quot;peanutbutter&quot;, the first part in regex</strong></td>
<td></td>
</tr>
<tr>
<td><code>/peanut(butter)?/</code></td>
<td><strong>&quot;peanut&quot; &quot;peatnutbutter &quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(\w+|FY\d{4})_report\.xls/</code></td>
<td>use the first part <code>/\w+/</code> to match <strong>&quot;FY2003_report&quot; and &quot;xls&quot; of &quot;FY2003_report.xls&quot;</strong>, the second part <code>/FY\d{4})_report\.xls/</code> is never used</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Simplest expression first<br>
<code>/\w+_\d{2,4}|\d{4}_\d{2}_\w+|export\d{2}/</code> =&gt; <code>/export\d{2}|\d{4}_\d{2}_\w+|\w+_\d{2,4}/</code></p>
</blockquote>
<h2>Anchors</h2>
<blockquote>
<p>Reference a <strong>position</strong>, has <strong>zero-length</strong> and <strong>not a character</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th>Metacharacter</th>
<th>Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^</code></td>
<td></td>
<td>Start of string/line</td>
</tr>
<tr>
<td><code>$</code></td>
<td></td>
<td>End of string/line</td>
</tr>
<tr>
<td><code>\A</code></td>
<td></td>
<td>Start of string, never end of line</td>
</tr>
<tr>
<td><code>\Z</code></td>
<td></td>
<td>End of string, never end of line</td>
</tr>
<tr>
<td><code>\b</code></td>
<td>Word Boundary</td>
<td>start/end of word</td>
</tr>
<tr>
<td><code>\B</code></td>
<td>Not Word Boundary</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Word boundary:</p>
<ul>
<li>Before and after the first and the last word character in the string (<strong>Word characters: <code>[A-Za-z0-9_]</code></strong>)</li>
<li>Between a word character and a non-word character</li>
<li>Space is not a word boundary</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>Single-line mode<br>
<code>^ $ \A \Z</code> do not match at line breaks</li>
<li>Multiline mode<br>
<code>^ $</code> match the start and the end of lines
<code>\A \Z</code> do not match at line breaks</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>Example</th>
<th>Match</th>
<th>Not match</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/^\w+@\w+\.[a-z]{3}$/</code></td>
<td><strong>&quot;nobody@nowhere.com&quot; &quot;abc@def.net&quot;</strong></td>
<td>&quot;nobody@nowhere.ca&quot;</td>
</tr>
<tr>
<td><code>/^[\t ]+/</code></td>
<td>all heading whitespaces</td>
<td></td>
</tr>
<tr>
<td><code>/[\t ]+$/</code></td>
<td>all trailing whitespaces</td>
<td></td>
</tr>
<tr>
<td><code>/^[a-z ]+/</code></td>
<td><strong>only &quot;apple&quot; in &quot;apple\norange&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/[a-z ]+$/</code></td>
<td><strong>only &quot;orange&quot; in &quot;apple\norange&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/^[a-z ]+/m</code></td>
<td><strong>&quot;apple\norange&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/[a-z ]+$/m</code></td>
<td><strong>&quot;apple\norange&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/^[a-z ]+$/m</code></td>
<td><strong>&quot;apple\norange&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/\b\w+\b/</code></td>
<td><strong>&quot;abc_123&quot;, &quot;This&quot; &quot;is&quot; &quot;a&quot; &quot;boundary&quot; in &quot;This is a boundary.&quot;, &quot;top&quot; &quot;notch&quot; in &quot;top-notch&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/\B\w+\B/</code></td>
<td><strong>&quot;hi&quot; &quot;oundar&quot; in &quot;This is a boundary.&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/apples\band\boranges/</code></td>
<td></td>
<td>&quot;apples and oranges&quot;</td>
</tr>
<tr>
<td><code>/apples\b \band\b \boranges/</code></td>
<td>&quot;apples and oranges&quot;</td>
<td></td>
</tr>
<tr>
<td><code>/\b[\w']+\b/</code></td>
<td><strong>&quot;a&quot; &quot;summer's&quot; &quot;day&quot; in &quot;a summer's day&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/\b[\w']+?\b/</code></td>
<td><strong>&quot;a&quot; &quot;summer&quot; &quot;'&quot; &quot;s&quot; &quot;day&quot; in &quot;a summer's day&quot;</strong> there are boundary after &quot;summer&quot; and before &quot;s&quot;</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Find word ending with &quot;s&quot;: <code>/\b\w+s\b/</code> is faster than <code>/\w+s/</code></p>
</blockquote>
<h2>Capturing Groups and Backreferences</h2>
<table>
<thead>
<tr>
<th>Metacharacter</th>
<th>Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\1</code> through <code>\9</code></td>
<td></td>
<td>Backreference for position 1 to 9. Some regex engines support <code>\1</code> to <code>\99</code> and use <code>$</code> instead of <code>\</code></td>
</tr>
<tr>
<td><code>?:</code></td>
<td></td>
<td>Specify a non-capturing group, place at the beginning of group expression <code>/(?:regex)/</code>, <code>?</code> = &quot;give this group a different meaning&quot; and <code>:</code> = &quot;non-capturing group&quot;</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Group expression <code>()</code> are automatically captured or stored the matched position for later use by default<br>
Example: <code>/a(p{2}l)e/</code> matches <strong>&quot;apple&quot;</strong> and store position of <strong>&quot;ppl&quot;</strong><br>
Backreferences allow access to these captured data</p>
<ul>
<li>can be used in the same regex as the group</li>
<li>can be accessed after the match is complete</li>
<li>cannot be used inside character classes</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th>Example</th>
<th>Match</th>
<th>Not match</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/(apples) to \1/</code></td>
<td><strong>&quot;apples to apples&quot;</strong></td>
<td>&quot;apples to \1&quot;</td>
</tr>
<tr>
<td><code>/(ab)(cd)(ef)\3\2\1/</code></td>
<td><strong>&quot;abcdefefcdab&quot;</strong></td>
<td>&quot;abcdedabcdef&quot;</td>
</tr>
<tr>
<td><code>/&lt;(i|em)&gt;.+?&lt;/\1&gt;/</code></td>
<td><strong>&quot;&lt;i&gt;Hello&lt;/i&gt;&quot; &quot;&lt;em&gt;Hello&lt;/em&gt;&quot;</strong></td>
<td>&quot;&lt;i&gt;Hello&lt;/em&gt;&quot; &quot;&lt;em&gt;Hello&lt;/i&gt;&quot;</td>
</tr>
<tr>
<td><code>/\b([A-Z][a-z]+)\b\s\b\1\w+\b/</code></td>
<td><strong>&quot;John Johnson&quot; &quot;Evan Evanson&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/\b(\w+)\s+\1\b/</code></td>
<td>find duplicate words, <strong>&quot;is is&quot;</strong> in <strong>&quot;This is is an apple&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(A?)B/</code></td>
<td><strong>&quot;AB&quot; and captures &quot;A&quot; or &quot;B&quot; and captures &quot;&quot;, element is optional but the group is not so it captures something</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(A?)B\1/</code></td>
<td><strong>&quot;ABA&quot; and &quot;B&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(A?)B\1C/</code></td>
<td><strong>&quot;ABAC&quot; and &quot;BC&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(A)?B/</code></td>
<td><strong>&quot;AB&quot; and captures &quot;A&quot; or &quot;B&quot; and captures nothing because element is not optional, the whole group <code>(A)</code> is optional</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(A)?B\1/</code></td>
<td><strong>&quot;ABA&quot;</strong></td>
<td>&quot;B&quot; (Except in JavaScript)</td>
</tr>
<tr>
<td><code>/(A) and (B) to \1/</code></td>
<td><strong>&quot;A and B to A&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(?:A) and (B) to \1/</code></td>
<td><strong>&quot;A and B to B&quot;</strong></td>
<td>&quot;A and B to A&quot;</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Find and Replace <strong>Name</strong> with <strong>Last Name,First Name</strong> in file <strong>us_presidents.txt</strong>, the result is in file <strong>us_presidents_find_replace_done.txt</strong></p>
<ol>
<li>Match the <strong>Number, Name, Start</strong> by <code>/^\d{1,2},[\w\.\s]+? [\w]+?,\d{4}/</code></li>
<li>Group <strong>Number, Last Name, First Name, Start</strong> by <code>/^(\d{1,2}),([\w\.\s]+?) ([\w]+?),(\d{4})/</code></li>
<li>Replace by backreferences <code>/$1,$3,$2,$4/</code></li>
</ol>
</blockquote>
<h2>Assertions</h2>
<blockquote>
<p>Position, zero-width, return true of false wheter it makes a match, but it does not actually match any characters<br>
<strong>Lookahead can be complex, but lookbehind should be simple</strong></p>
<ol>
<li>Look forward or backward</li>
<li>Match string using multiple expressions</li>
<li>Reject expressions with lookbehind assertion</li>
<li>Find the last occurrence</li>
<li>Find the position only for inserting with combination of lookahead and lookbehind assertions</li>
</ol>
</blockquote>
<table>
<thead>
<tr>
<th>Metacharacter</th>
<th>Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>?=</code></td>
<td></td>
<td>Positive lookahead assertion, place at the beginning of group expression <code>/(?=regex)/</code></td>
</tr>
<tr>
<td><code>?!</code></td>
<td></td>
<td>Negative lookahead assertion, place at the beginning of group expression <code>/(?!regex)/</code></td>
</tr>
<tr>
<td><code>?&lt;=</code></td>
<td></td>
<td>Positive lookbehind assertion, place at the beginning of group expression <code>/(?&lt;=regex)/</code></td>
</tr>
<tr>
<td><code>?&lt;!</code></td>
<td></td>
<td>Negative lookbehind assertion, place at the beginning of group expression <code>/(?&lt;!regex)/</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p>Lookbehind assertion accept fixed length, simple regex such as literal text, character classes, fixed length alternation (<code>/(?&lt;=cat|rat|fat)/</code> not <code>/(?&lt;=cat|fish|width)/</code>) but not repetition or optional expressions</p>
</blockquote>
<table>
<thead>
<tr>
<th>Example</th>
<th>Match</th>
<th>Not match</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/(?=seashore)sea/</code></td>
<td><strong>&quot;sea&quot; in &quot;seashore&quot;</strong> find the assertion before match the word, so it travel the word &quot;sea&quot; 2 times</td>
<td>&quot;sea&quot; in &quot;seaside&quot;</td>
</tr>
<tr>
<td><code>/sea(?=shore)/</code></td>
<td><strong>&quot;sea&quot; in &quot;seashore&quot;</strong> match the word before checking the assertion</td>
<td>&quot;sea&quot; in &quot;seaside&quot;</td>
</tr>
<tr>
<td><code>/\b[\w']+\b,/</code></td>
<td>all words followed with a comma</td>
<td></td>
</tr>
<tr>
<td><code>/\b[\w']+\b(?=,)/</code></td>
<td>all words followed with a comma but not select the comma</td>
<td></td>
</tr>
<tr>
<td><code>/\d{3}-\d{3}-\d{4}/</code></td>
<td><strong>&quot;555-302-4321&quot; &quot;555-789-6798&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/^[0-5\-]+$/</code></td>
<td>any string contains 0 to 5 and &quot;-&quot;</td>
<td></td>
</tr>
<tr>
<td><code>/(?=^[0-5\-]+$)\d{3}-\d{3}-\d{4}/</code></td>
<td>any US phone number contains only 0 to 5 digits <strong>&quot;555-302-4321&quot; &quot;555-302-1234&quot;</strong>, 2 regexs running in the same string</td>
<td></td>
</tr>
<tr>
<td><code>/(?=^[0-5\-]+$)(?=.*1234)\d{3}-\d{3}-\d{4}/</code></td>
<td>any US phone number contains only 0 to 5 digits and ending with &quot;1234&quot; <strong>&quot;555-302-1234&quot;</strong>, 3 regexs running in the same string</td>
<td></td>
</tr>
<tr>
<td><code>/\b(?=\w*tr)[\w']+\b(?=,)/</code></td>
<td>all words contain &quot;tr&quot; and followed with a comma but not select the comma</td>
<td></td>
</tr>
<tr>
<td><code>^(?=.*\d).{8,15}$</code></td>
<td>a string with length from 8 to 15 characters, contains a digit</td>
<td></td>
</tr>
<tr>
<td><code>^(?=.*\d)(?=.*[A-Z]).{8,15}$</code></td>
<td>a string with length from 8 to 15 characters, contains a digit and a capitalized character</td>
<td></td>
</tr>
<tr>
<td><code>/(?!seashore)sea/</code></td>
<td>any string start with <strong>&quot;sea&quot;</strong> but not &quot;seashore&quot;</td>
<td></td>
</tr>
<tr>
<td><code>/sea(?!shore)/</code></td>
<td>any string start with <strong>&quot;sea&quot;</strong> but not &quot;seashore&quot;</td>
<td></td>
</tr>
<tr>
<td><code>/online(?! training)/</code></td>
<td></td>
<td>does not match &quot;online training&quot;</td>
</tr>
<tr>
<td><code>//online(?!.*training)</code></td>
<td></td>
<td>does not match &quot;online anything training&quot;</td>
</tr>
<tr>
<td><code>/(?=^[0-5\-]+$)(?!.*1234)\d{3}-\d{3}-\d{4}/</code></td>
<td>any US phone number contains only 0 to 5 digits and not ending with &quot;1234&quot; <strong>&quot;555-302-1235&quot;</strong>, 3 regexs running in the same string</td>
<td></td>
</tr>
<tr>
<td><code>/\b[\w']+\b(?![,\.]])/</code></td>
<td>all words not followed with a comma or period</td>
<td></td>
</tr>
<tr>
<td><code>/\blastWord\b(?!.*\blastWord\b)/</code></td>
<td>find the last occurent of <strong>&quot;lastWord&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(\blastWord\b)(?!.*\1)/</code></td>
<td>find the last occurent of <strong>&quot;lastWord&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(?&lt;=base)ball/</code></td>
<td><strong>&quot;ball&quot;</strong> in <strong>&quot;baseball&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/ball(?&lt;=baseball)/</code></td>
<td><strong>&quot;ball&quot;</strong> in <strong>&quot;baseball&quot;</strong>, rarely use this way</td>
<td></td>
</tr>
<tr>
<td><code>/(?&lt;!base)ball/</code></td>
<td><strong>&quot;ball&quot;</strong> in <strong>&quot;anythingball&quot;</strong></td>
<td>&quot;baseball&quot;</td>
</tr>
<tr>
<td><code>/(?&lt;=Ben)(jamin|ny)/</code></td>
<td><strong>&quot;jamin&quot;, &quot;ny&quot;</strong> in <strong>&quot;Benjamin Benny&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(?&lt;![$\d])\d+\.\d\d/</code></td>
<td><strong>&quot;78.99&quot;</strong></td>
<td>&quot;$78.99&quot; &quot;7.89&quot;</td>
</tr>
<tr>
<td><code>/(?&lt;![$\d])(?=\d+\.\d\d)/</code></td>
<td><strong>zero-width is matched, the regex pointer is in front of &quot;7&quot; for &quot;78.99&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(?&lt;=\d)(\d\d\d)+(?!\d)/</code></td>
<td>sets of 3 digits that have a number in front of them and do not have a number after them, <strong>&quot;345678&quot; in &quot;12345678.9&quot; or  &quot;345&quot; in &quot;12345&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/(?&lt;=\d)(?=(\d\d\d)+(?!\d))/</code></td>
<td>insert the pointer in front of sets of 3 digits that have a number in front of them and do not have a number after them</td>
<td></td>
</tr>
</tbody>
</table>
<h2>Unicode</h2>
<blockquote>
<p>Use variable byte size to encode characters</p>
</blockquote>
<table>
<thead>
<tr>
<th>Metacharacter</th>
<th>Name</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>\u</code></td>
<td></td>
<td>follow by 4 hex number range from 0000 to FFFF, support by Java, JavaScript, .NET, Python, Ruby</td>
</tr>
<tr>
<td><code>\x</code></td>
<td></td>
<td>follow by 4 hex number range from 0000 to FFFF, support by Perl and PHP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Example</th>
<th>Match</th>
<th>Not match</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>/caf\u00E9/</code></td>
<td><strong>&quot;café&quot;</strong></td>
<td></td>
</tr>
<tr>
<td><code>/caf\u0065\u0301/</code></td>
<td><strong>&quot;café&quot;</strong> <code>\u0065</code> is the character <strong>&quot;e&quot;</strong></td>
<td></td>
</tr>
</tbody>
</table>
<h2>Useful Regex</h2>
<table>
<thead>
<tr>
<th>Possible Target</th>
<th>Description</th>
<th>Regex</th>
<th>Match Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>Names</td>
<td>FirstName MiddleName LastName</td>
<td><code>^([A-Z][A-Za-z.'\-]+) (([A-Z][A-Za-z.'\-]+) )?([A-Z][A-Za-z.'\-]+)$</code></td>
<td>&quot;George Washington&quot;, &quot;Albert Einstein&quot;, &quot;Anna K. Behrensmeyer&quot;, &quot;Blaise Pascal&quot;, &quot;Caroline Herschel&quot;, &quot;Cecilia Payne-Gaposchkin&quot;, &quot;Chien-Shiung Wu&quot;, &quot;Dorothy Hodgkin&quot;, &quot;Edmond Halley&quot;, &quot;Edwin Powell Hubble&quot;, &quot;Elizabeth Blackburn&quot;, &quot;Enrico Fermi&quot;, &quot;Erwin Schroedinger&quot;, &quot;Flossie Wong-Staal&quot;, &quot;Frieda Robscheit&quot;-Robbins&quot;, &quot;Geraldine Seydoux&quot;, &quot;Gertrude B. Elion&quot;, &quot;Ingrid Daubechies&quot;, &quot;Jacqueline K. Barton&quot;, &quot;Jane Goodall&quot;, &quot;Jocelyn Bell Burnell&quot;, &quot;Johannes Kepler&quot;, &quot;Lene Vestergaard Hau&quot;, &quot;Lise Meitner&quot;, &quot;Lord Kelvin&quot;, &quot;Maria Mitchell&quot;, &quot;Marie Curie&quot;, &quot;Max Born&quot;, &quot;Max Planck&quot;, &quot;Melissa Franklin&quot;, &quot;Michael Faraday&quot;, &quot;Mildred S. Dresselhaus&quot;, &quot;Nicolaus Copernicus&quot;, &quot;Niels Bohr&quot;, &quot;Patricia S. Goldman-Rakic&quot;, &quot;Patty Jo Watson&quot;, &quot;Polly Matzinger&quot;, &quot;Richard Phillips Feynman&quot;, &quot;Rita Levi-Montalcini&quot;, &quot;Rosalind Franklin&quot;, &quot;Ruzena Bajcsy&quot;, &quot;Sarah Boysen&quot;, &quot;Shannon W. Lucid&quot;, &quot;Shirley Ann Jackson&quot;, &quot;Sir Ernest Rutherford&quot;, &quot;Sir Isaac Newton&quot;, &quot;Stephen Hawking&quot;, &quot;Werner Karl Heisenberg&quot;, &quot;Wilhelm Conrad Roentgen&quot;, &quot;Wolfgang Ernst Pauli&quot;</td>
</tr>
<tr>
<td>US Postal Codes</td>
<td>Five digits; Five digits, dash, four digits</td>
<td><code>^\d{5}(-\d{4})?$</code></td>
<td>&quot;21342&quot;, &quot;32145-3247&quot;</td>
</tr>
<tr>
<td>Canada Postal Codes</td>
<td>&quot;A9A 9A9&quot;, where A is a character from A-Z and 9 is a digit from 0-9</td>
<td><code>^[A-Z]\d[A-Z] \d[A-Z]\d$</code></td>
<td>&quot;V5G 3Y2&quot;, &quot;B3Z 2W4&quot;</td>
</tr>
<tr>
<td>UK Postal Codes</td>
<td>&quot;A9 9AA&quot;; &quot;A99 9AA&quot;; &quot;AA9 9AA&quot;; &quot;AA99 9AA&quot;; &quot;A9A 9AA&quot;; &quot;AA9A&quot; &quot;9AA&quot;</td>
<td><code>^[A-Z](\d[A-Z]?|[A-Z0-9]\d|[A-Z]\d[A-Z0-9]) \d[A-Z][A-Z]$</code> or <code>^([A-Z]{1,2}\d{1,2}|[A-Z]{1,2}\d[A-Z]) \d[A-Z]{2}$</code></td>
<td>&quot;A9 9AA&quot;; &quot;A99 9AA&quot;; &quot;AA9 9AA&quot;; &quot;AA99 9AA&quot;; &quot;A9A 9AA&quot;; &quot;AA9A&quot; &quot;9AA&quot;</td>
</tr>
<tr>
<td>Email</td>
<td>&quot;someone@somewhere.com&quot;</td>
<td><code>^[\w.%+\-]+@[\w.\-]+\.\[A-Za-z]{2,6}$</code></td>
<td>&quot;nvdhau@gmail.com&quot;, &quot;abc@hcmiu.edu.vn&quot;</td>
</tr>
<tr>
<td>URL</td>
<td>&quot;http://www.nowhere.com&quot;; &quot;http://nowhere.com&quot;; &quot;http://blog.nowhere.com&quot;; &quot;https://nowhere.com&quot;; &quot;http://nowhere.com/products.html&quot;; &quot;http://nowhere.com/imgs/img-1.png&quot;; &quot;http://nowhere.com/product/3378&quot;; &quot;http://nowhere.com/products.php?id=78&quot;; &quot;http://nowhere.com/products.php?id=78&amp;color=black&quot;; &quot;http://nowhere.com#about&quot;; &quot;http://168.192.255.186&quot;</td>
<td><code>^(?:http|https):\/\/[\w.\-]+(?:\.[\w+\-]+)+[\w\-.,@?^=%&amp;:;/~\\+#]+$</code></td>
<td></td>
</tr>
<tr>
<td>Decimal Numbers</td>
<td>&quot;5.1&quot;; &quot;312.32142&quot;; &quot;0.1234&quot;; &quot;.321&quot;; &quot;67&quot;</td>
<td><code>^(\d*\.\d+|\d+)$</code></td>
<td></td>
</tr>
<tr>
<td>Currency</td>
<td>&quot;$43&quot;; &quot;$321.00&quot;; &quot;$0.32&quot;; &quot;$.50&quot;; &quot;£321&quot;</td>
<td><code>^(\$|\u00A3)(\d*\.\d{2}|\d+)$</code></td>
<td></td>
</tr>
<tr>
<td>IP Address</td>
<td>&quot;0.0.0.0&quot; to &quot;255.255.255.255&quot; and can have leading 0 &quot;067.032.143.089&quot;</td>
<td><code>^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$</code></td>
<td></td>
</tr>
<tr>
<td>Dates</td>
<td>&quot;2000-11-15&quot;; &quot;2000-6-9&quot;; &quot;2000-06-09&quot;; &quot;2000/6/9&quot;</td>
<td><code>^(19[5-9][0-9]|20[0-4][0-9]|2050)[-\/](0?[0-9]|1[0-2])[-\/](3[01]|[12][0-9]|0?[1-9])$</code></td>
<td>from 1950 to 2050</td>
</tr>
<tr>
<td>Times</td>
<td>&quot;2:34&quot;; &quot;2:34am&quot;; &quot;2:34PM&quot;; &quot;02:34&quot;</td>
<td><code>^(0?[1-9]|1[0-2]):([0-5][0-9])([aApP][mM])?$</code></td>
<td></td>
</tr>
<tr>
<td>Times</td>
<td>&quot;14:34&quot;; &quot;14:34:56&quot;; &quot;14:56 EST&quot;; &quot;14:34 GMT -5&quot;</td>
<td><code>^([0-1]?[0-9]|2[0-3]):([0-5][0-9])(:([0-5][0-9]))?( ([A-Z]{3}|GMT [-+]([0-9]|1[02])))?$</code></td>
<td></td>
</tr>
<tr>
<td>HTML tags</td>
<td>&quot;<tag>texts</tag>&quot;; &quot;<tag id="id1" class="class1">texts</tag>&quot;; &quot;<tag />&quot;</td>
<td><code>^&lt;(?:([A-Za-z][A-Za-z0-9]*)\b[^&gt;]*&gt;(?:.*?)&lt;/\1&gt;|[A-Za-z][A-Za-z0-9]*\b[^&gt;]/&gt;)$</code></td>
<td></td>
</tr>
<tr>
<td>Passwords</td>
<td>any character except space; characters length in range 8-15; must include 1 uppercase, 1 lowercase, 1 digit and 1 symbol</td>
<td><code>^(?=.*[~!@#$%^&amp;*()\-+=|\\{}[\]:;&lt;&gt;?/])(?=.*\d)(?=.*[A-Z])(?=.*[a-z])\S{8,15}$</code></td>
<td></td>
</tr>
</tbody>
</table>
